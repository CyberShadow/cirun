/**
 * Installation of git hooks.
 *
 * License:
 *   This Source Code Form is subject to the terms of
 *   the Mozilla Public License, v. 2.0. If a copy of
 *   the MPL was not distributed with this file, You
 *   can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * Authors:
 *   Vladimir Panteleev <vladimir@cy.md>
 */

module cirun.cli.githook;

import std.algorithm.iteration;
import std.array;
import std.conv : octal;
import std.exception;
import std.file;
import std.path;
import std.string;

import ae.sys.cmd;

import cirun.common.config;

void installGitHook(string kind, string repositoryPath, string repositoryName)
{
	// Do this first to validate the hook kind
	auto hookScript = genHookScript(kind, repositoryName);

	auto hookDir = query(["git", "-C", repositoryPath, "rev-parse", "--git-path", "hooks"]).chomp();
	hookDir = repositoryPath.buildPath(hookDir);

	auto hookPath = hookDir.buildPath(kind);
	enforce(!hookPath.exists, "The hook " ~ hookPath ~ " already exists.");

	write(hookPath, hookScript);
	version (Posix)
		hookPath.setAttributes(hookPath.getAttributes | octal!111); // +x
}

private:

string genHookScript(string kind, string repositoryName)
{
	switch (kind)
	{
		case "post-commit":
			return q"EOF
#!/bin/sh
#
# Git post-commit hook to trigger a cirun job.
# Auto-generated by cirun.

set -eu
commit=$(git rev-parse HEAD)
git_dir=$(git rev-parse --absolute-git-dir)
message=$(git log -1 --format=%%B)
author_name=$(git log -1 --format=%%an)
author_email=$(git log -1 --format=%%ae)
ref=$(git rev-parse --symbolic-full-name HEAD)

run() {
	exec %-(%s %) run --quiet \
		%s "$commit" \
		--clone-url "$git_dir" \
		--commit-message "$message" \
		--commit-author-name  "$author_name"  \
		--commit-author-email "$author_email" \
		"$@"
}

if [ "$ref" = HEAD ] ; then
	run
else
	run --ref "$ref"
fi
EOF"
				.format(
					selfCmdLine.map!escapePosixShellArgument,
					repositoryName.escapePosixShellArgument,
				);

		case "pre-push":
			return q"EOF
#!/bin/sh
#
# Git pre-push hook to check cirun status.
# Forbids pushing unless the cirun job for the pushed ref succeeded.
# Auto-generated by cirun.

set -eu
git_dir=$(git rev-parse --absolute-git-dir)
while read -r local_ref local_sha1 remote_ref remote_sha1
do
	printf -- 'Checking cirun status for %%s (%%s)...\n' "$local_ref" "$local_sha1" 1>&2
	message=$(git log -1 --format=%%B "$local_sha1")
	author_name=$(git log -1 --format=%%an "$local_sha1")
	author_email=$(git log -1 --format=%%ae "$local_sha1")
	job_id=$(%1$-(%s %) run --quiet --wait \
		--job-id-file=- \
		%2$s "$local_sha1" \
		--clone-url "$git_dir" \
		--ref "$local_ref" \
		--commit-message "$message" \
		--commit-author-name "$author_name" \
		--commit-author-email "$author_email")
	status=$(%1$-(%s %) status "$job_id" --format=%%s)
	if [ "$status" != success ]
	then
		%1$-(%s %) status "$job_id"
		exit 1
	fi
done
EOF"
				.format(
					selfCmdLine.map!escapePosixShellArgument.array,
					repositoryName.escapePosixShellArgument,
				);

		case "post-receive":
			return q"EOF
#!/bin/sh
#
# Git post-receive hook to trigger cirun jobs.
# Auto-generated by cirun.

set -eu
unset GIT_DIR # Don't propagate to cirun jobs

git_dir=$(git rev-parse --absolute-git-dir)
while read -r old_sha1 new_sha1 ref
do
	message=$(git log -1 --format=%%B "$new_sha1")
	author_name=$(git log -1 --format=%%an "$new_sha1")
	author_email=$(git log -1 --format=%%ae "$new_sha1")
	%-(%s %) run --quiet \
		%s "$new_sha1" \
		--clone-url "$git_dir" \
		--ref "$ref" \
		--commit-message "$message" \
		--commit-author-name "$author_name" \
		--commit-author-email "$author_email"
done
EOF"
				.format(
					selfCmdLine.map!escapePosixShellArgument.array,
					repositoryName.escapePosixShellArgument,
				);

		case "update":
			return q"EOF
#!/bin/sh
#
# Git update hook to check incoming ref updates using cirun.
# Auto-generated by cirun.

set -eu
unset GIT_DIR # Don't propagate to cirun jobs

ref=$1
commit=$3
git_dir=$(git rev-parse --absolute-git-dir)
message=$(git log -1 --format=%%B "$commit")
author_name=$(git log -1 --format=%%an "$commit")
author_email=$(git log -1 --format=%%ae "$commit")
job_id=$(%1$-(%s %) run --quiet --wait \
	--job-id-file=- \
	%2$s "$commit" \
	--clone-url "$git_dir" \
	--ref "$ref" \
	--commit-message "$message" \
	--commit-author-name "$author_name" \
	--commit-author-email "$author_email")
status=$(%1$-(%s %) status "$job_id" --format=%%s)
if [ "$status" != success ]
then
	%1$-(%s %) status "$job_id"
	exit 1
fi
EOF"
				.format(
					selfCmdLine.map!escapePosixShellArgument.array,
					repositoryName.escapePosixShellArgument,
				);

		default:
			throw new Exception("Unknown hook kind");
	}
}

string escapePosixShellArgument(string arg)
{
	return `'` ~ replace(arg, `'`, `'\''`) ~ `'`;
}
